var gdjs;(function(M){const b={3:0,2:1,5:2,4:3,0:4,1:5},r={0:3,1:2,2:5,3:4,4:0,5:1},h={0:[0,0],1:[1,0],2:[0,1],3:[1,1]},_={0:[0,1],1:[0,0],2:[1,1],3:[1,0]};let g;const T=()=>(g||(g=new THREE.MeshBasicMaterial({transparent:!0,opacity:0,alphaTest:1})),g),n=(c,t)=>c.isFaceAtIndexVisible(t)?c.getInstanceContainer().getGame().getImageManager().getThreeMaterial(c.getFaceAtIndexResourceName(t),{useTransparentTexture:c.shouldUseTransparentTexture(),forceBasicMaterial:c._materialType===M.Cube3DRuntimeObject.MaterialType.Basic}):T();class f extends M.RuntimeObject3DRenderer{constructor(t,i){const l=new THREE.BoxGeometry(1,1,1),m=[n(t,r[0]),n(t,r[1]),n(t,r[2]),n(t,r[3]),n(t,r[4]),n(t,r[5])],x=new THREE.Mesh(l,m);super(t,i,x);this._boxMesh=x,this._cube3DRuntimeObject=t,this.updateSize(),this.updatePosition(),this.updateRotation()}updateFace(t){const i=b[t];i!==void 0&&(this._boxMesh.material[i]=n(this._cube3DRuntimeObject,t),this._cube3DRuntimeObject.isFaceAtIndexVisible(t)&&this.updateTextureUvMapping(t))}updateSize(){super.updateSize(),this.updateTextureUvMapping()}updateTextureUvMapping(t){const i=this._boxMesh.geometry.getAttribute("position"),l=this._boxMesh.geometry.getAttribute("uv"),m=t===void 0?0:b[t]*4,x=t===void 0?23:b[t]*4+3;for(let e=m;e<=x;e++){const R=Math.floor(e/4),o=this._boxMesh.material[R];if(!o||!o.map)continue;const u=this._cube3DRuntimeObject.shouldRepeatTextureOnFaceAtIndex(r[R]),d=this._cube3DRuntimeObject.getFacesOrientation()==="Y";let a,s;switch(R){case 0:u?d?(a=-(this._boxMesh.scale.z/o.map.source.data.width)*(i.getZ(e)-.5),s=-(this._boxMesh.scale.y/o.map.source.data.height)*(i.getY(e)+.5)):(a=-(this._boxMesh.scale.y/o.map.source.data.width)*(i.getY(e)-.5),s=this._boxMesh.scale.z/o.map.source.data.height*(i.getZ(e)-.5)):d?[a,s]=h[e%4]:[a,s]=_[e%4];break;case 1:u?d?(a=this._boxMesh.scale.z/o.map.source.data.width*(i.getZ(e)+.5),s=-(this._boxMesh.scale.y/o.map.source.data.height)*(i.getY(e)+.5)):(a=this._boxMesh.scale.y/o.map.source.data.width*(i.getY(e)+.5),s=this._boxMesh.scale.z/o.map.source.data.height*(i.getZ(e)-.5)):d?[a,s]=h[e%4]:([a,s]=_[e%4],a=-a,s=-s);break;case 2:u?(a=this._boxMesh.scale.x/o.map.source.data.width*(i.getX(e)+.5),s=this._boxMesh.scale.z/o.map.source.data.height*(i.getZ(e)-.5)):[a,s]=h[e%4];break;case 3:u?d?(a=this._boxMesh.scale.x/o.map.source.data.width*(i.getX(e)+.5),s=-(this._boxMesh.scale.z/o.map.source.data.height)*(i.getZ(e)+.5)):(a=-(this._boxMesh.scale.x/o.map.source.data.width)*(i.getX(e)-.5),s=this._boxMesh.scale.z/o.map.source.data.height*(i.getZ(e)-.5)):([a,s]=h[e%4],d||(a=-a,s=-s));break;case 4:u?(a=this._boxMesh.scale.x/o.map.source.data.width*(i.getX(e)+.5),s=-(this._boxMesh.scale.y/o.map.source.data.height)*(i.getY(e)+.5)):[a,s]=h[e%4];break;case 5:const p=this._cube3DRuntimeObject.getBackFaceUpThroughWhichAxisRotation()==="X";u?(a=(p?1:-1)*(this._boxMesh.scale.x/o.map.source.data.width)*(i.getX(e)+(p?1:-1)*.5),s=(p?1:-1)*(this._boxMesh.scale.y/o.map.source.data.height)*(i.getY(e)+(p?-1:1)*.5)):([a,s]=h[e%4],p&&(a=-a,s=-s));break;default:[a,s]=h[e%4]}l.setXY(e,a,s)}l.needsUpdate=!0}_updateMaterials(){for(let t=0;t<6;t++)this.updateFace(t)}}M.Cube3DRuntimeObjectRenderer=f})(gdjs||(gdjs={}));
//# sourceMappingURL=Cube3DRuntimeObjectPixiRenderer.js.map
